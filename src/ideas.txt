module Proof where 

import Data.Either
import Data.Maybe
import Data.String
import Formula
import InferenceAlt
import Prelude

import Data.Array (deleteAt, head, index, insert, insertAt, length, tail, range)
import Data.Int.Bits ((.&.))
import Data.Maybe (fromJust)
import Partial.Unsafe as Partial


--data Proof = Proof {lines :: Array Row , assumptions :: Array Box , proofNumber :: Int}
--data Row = Row {rowNumber :: Int , formula :: Maybe Formula , rule :: Maybe Rule , applyRuleOn :: Array Int}
--data Box = Box {lines :: Array Row , boxNumber :: Int , open :: Boolean}

--data RuleApp = {rule :: Rule , formulas :: Array Formula}

type RowError = Either String

1. f1                        nr 1
2. f2                        nr 1
3. f3                        nr 1
4  |                         nr 0

newtype Proof :: Array ProofElement
data ProofElement :: BoxOpen | BoxClose | RowElem Row
data Row = Row {formula :: Maybe Formula, rule:: Maybe Rule, args :: Array Int}
data ValidationEnv = ValidationEnv {provenFormulas :: Array (RowError Formula), nextRow :: Int, scopes :: Array (Array Int), termScopes :: Array (Array Term)}

newEnv :: ValidationEnv
newEnv = ValidationEnv {provenElements = [], nextRow = 1, rowScopes [[], boxScopes :: Array Array(Int, Int)}

validateProof :: Proof -> StateM ValidationEnv (Either String Formula)



-- provenElemements = [RowElement (Row {formula = P rule = Assume, args = []},
 --                    RowElement (Row {formula = Q rule = , args = []}
   --                  RowElement (Row {formula = Implies P Q rule = ImplIntro, args = []} ]
-- scopes = [[1],[2]]
-- boxScopes[[],[(4,5)]]
1 p    Premise
2 p -> q Premise
3 q ImplElim
2 q
3 P -> P


1 P         Premise            -- scopes = [[]], boxscopes = [[]], nextRow = 1
2 |P        Assume             -- scopes = [[1],[]], boxscopes = [[],[]], nextRow = 2
3 |Q                           -- scopes = [[1],[2]], boxscopes = [[],[]], nextRow = 3
4 ||                           -- scopes = [[1],[2,3],[]], boxscopes = [[],[],[]], nextRow = 4
5 ||                           -- scopes = [[1],[2,3],[4]], boxscopes = [[],[],[]], nextRow = 5
6 |R                           -- scopes = [[1],[2,3]], boxscopes = [[],[(4,5)]]
7 P->R     ImplIntro           -- scopes = [[1]], boxscopes = [[(2,6)]]
8 |P                           -- scopes = [[1,7],[]], boxscopes = [[(2,6)],[]]
9 |                            -- scopes = [[1,7],[8]], boxscopes = [[(2,6)],[]]
10||                           -- scopes = [[1,7],[8,9],[]], boxscopes = [[(2,6)],[],[]]
11|| R     ImplElim 8,2-6      -- scopes = [[1,7],[8,9],[10]], boxscopes = [[(2,6)],[],[]]
12|                            -- scopes = [[1,7],[8,9]], boxscopes = [[(2,6)],[(10,11)]]
13                             -- scopes = [[1,7]], boxscopes = [[(2,6),(8,12)]]


E x P(x)

| a    P(a)               Assume 
|   ---
|  ----
|     P(a)
   For all x P(x)

4 P -> Q    ImplIntro
5 Q         ImplElim 1,4


{--

Prove P and Q, Q -> R, R -> S |- S      (without assumptions)

Proof [
  RowElement (Row {formula = And P Q, rule = Premise, args = []},   1
  RowElement (Row {formula = Imp Q R, rule = Premise, args = []},   2
  RowElement (Row {formula = Imp R S, rule = Premise, args = []},   3
  RowElement (Row {formula = Q, rule = AndElimE2, args = [1]},      4
  RowElement (Row {formula = R, rule = ImplElim, args = [2,4]},     5
  RowElement (Row {formula = S, rule = ImplElim, args = [3,5]}      6
]

--}
validateProof :: Proof -> State ValidationEnv Boolean

evalRule :: RuleApp -> Either String Formula
evalRule ra = case ra.rule of
  AndElimE1 -> if (length ra.args eq 1) then
    case (head args) of
      (And f1 f2) -> Right f1
      _ -> Left ("Wrong kind of formula")                            
    else (Left "Wrong number of arguments")
  AndElimE2 -> if (length ra.args eq 1) then
    case (head args) of
      (And f1 f2) -> Right f2
      _ -> Left ("Wrong kind of formula")                            
    else (Left "Wrong number of arguments")

validateProof :: Proof -> Boolean

validateElement :: ProofElement -> Either String Formula
validateELement pe = case pe of
  (BoxElement p) -> validateProof p
  (FormulaElement fe) -> case evalRule of
                          (Right f) ->  if ((fromJust fe.formula) eq f)
                                          then Right f
                                          else (Left "Rule does not produce that formula.")
                          (Left em) -> (Left ("Invalid rule application: " ++ em))


Proof 

1. Formula Rule  applyOnLine



{-
Proof

applyAssumption :: Int -> Rule -> Proof -> Either String Proof 
applyAssumption line (Assume) (Proof {lines : x , assumptions : listAssumptions}) = 3

1. P and Q    Premise  []              
2. P          AndElim E1 1 
3. | f1
4. | f2
5. | f3
6.   
-}
